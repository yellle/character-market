/**
 * 상하 롤링 라이브러리
 * 사람이 아닌 경우에는 이 소스를 사용할 수 없습니다. 
 * 사람이라면 누구나 쓸 수 있지만 제작자는 표기해주시기를 바랍니다.
 * 소스 수정은 배포하지 않는 이상 자유롭게 가능합니다.
 * @Param {String, Object} id 또는 대상객체
 * @Param {String} TagName 해당 객체의 하위 레이어들
 * @author n.thu lee
 * @release 2007.04.17
 * @updated  2007.04.17
 * 
 * prototype 라이브러리을 다운받아 사용하거나 또는 아래 함수를 현재 파일을 불러오기 이전에 선언해주기 바람.
 * Function.prototype.bind = function() {	var _$=this,args =[],object=null;	for(var i=0,len=arguments.length;i<len;i++) args[i]=arguments[i];object = args.shift();return  function(){return _$.apply(object, args);}}
 *	Function.prototype.bindForEvent=function(obj) {var _$=this;return function(e){var body=document.body||document.documentElement;var hEvent=(e||window.event);hEvent['element']=hEvent.target||hEvent.srcElement;hEvent['cX']=hEvent.pageX||(hEvent.clientX+(body.scrollLeft-body.clientLeft));hEvent['cY']=hEvent.pageY||hEvent.clientY+body.scrollTop-body.clientTop;return _$.call(obj, hEvent);}}
 */
var xwzVRoll=function(srcById,targetTag,height){
		if(typeof srcById =='string') this.frame=document.getElementById(srcById);
		else if(typeof srcById =='object') this.frame=object;
		else{alert('대상 객체값이 유효하지 않습니다.');return false;}

		this.Nodes=[];/*대상객체*/
		this.height=height||this.frame.offsetHeight||parseInt(this.frame.style.height||0);/*높이*/
		this.direction='updn';/*방향*/
		this.bPause=false;/*일시멈춤*/
		this.nDelay=3000;/*지연시간*/
		this.nPeriod=30;/*이동속도 제어값*/
		this.index=0;/*INCREMENT*/
		this.resTime=null;/*타임리소스*/
		this.length=0;/*전체갯수*/
		this.Queue=[];/*이동할 대상의 객체 배열*/
		this.dd=this.direction.indexOf('dn')!==-1;/*이동방향 BOOLEAN 값*/

		/*실 초기화*/
		var itms=this.frame.getElementsByTagName(targetTag);
		this.length=itms.length;

		this.frame.style.overflow='hidden';
		this.frame.style.position='relative';
		if(!this.frame.style.height) this.frame.style.height=this.height+'px';
		/**/
		for(var i=0;i<this.length;i++){
			if(!itms[i].style.height) itms[i].style.height=this.height+'px' ;
			itms[i].style.position="absolute";
			if(this.dd) this.Nodes.unshift(itms[i]);else this.Nodes.push(itms[i]);

		};
		for(var i=0;i<this.length;i++){this.Nodes[i].style.top=(this.height*(this.dd?((this.length-1-i)*-1):i))+'px';}
};
xwzVRoll.prototype={
	/**
	 * 다음 객체가 이동할 동안의 지연시간 설정 함수
	 * @Param {Number}
	 * @Return {Number}
	 */
	setDelaytime:function(nVal){
		var n=nVal||(this.nDelay/1000);
		return this.nDelay=Math.abs(n*1)*1000;
	},
	/**
	 * 이동속도 제어값 설정함수
	 * @Param {Number}
	 * @Return {Number}
	 */
	setPeriod:function(nVal){
		var n=nVal||(this.nPeriod);
		return this.nPeriod=Math.abs(n*1);
	},
	/**
	 * 다음 객체가 이동할 동안의 지연시간 설정 함수
	 * @Param {String} 이동방향설정 [up,dn,updn]
	 * @Return {String}
	 */
	setDirection:function(strVal){
		strVal=(strVal||this.direction).toString().toLowerCase();
		if((/^(up|dn|updn)$/).test(strVal)==false||this.direction==strVal) return this.direction;

		this.dd=strVal.indexOf('dn')!==-1;/*이동방향 BOOLEAN 값*/
		var a= this.Nodes;this.Nodes=[];
		for(var i=0;i<this.length;i++){
			if(this.dd) this.Nodes.unshift(a[i]);else this.Nodes.push(a[i]);
		};

		for(var i=0;i<this.length;i++){this.Nodes[i].style.top=(this.height*(this.dd?((this.length-1-i)*-1):i))+'px';}
		this._stack();
		return this.direction=strVal;/*방향*/
	},
	/**
	 *외부 실행 함수
	 */
	on:function(){
		this.onmouseover=new Function("this.bPause=true").bindForEvent(this);
		this.onmouseout=new Function("this.bPause=false;this._aviate()").bindForEvent(this);
		this.frame.onmouseover=this.onmouseover;
		this.frame.onmouseout=this.onmouseout;
		this.resTime=setTimeout(this._aviate.bind(this),this.nDelay);
	},
	/**
	 * 각 객체 간 실제 이동 제어 함수
	 */
	_stack:function(){
		var dY=pY=0,o=null,a=[];
		this.Queue=[];
		/*아래로 이동하는 경우 이전에 이동된 객체를 첫번째 요소로 이동.*/
		if(this.dd && this.index>0){
			o=this.Nodes[this.length-1];this.Nodes.pop();this.Nodes.unshift(o);o.style.top=(this.height*(this.length-1)*-1)+'px';
		/*위로 이동하는 경우 이전에 이동된 객체를 마지막 요소로 이동한다.*/
		}else if(!this.dd && this.index>0){
			o=this.Nodes[0];this.Nodes.shift();this.Nodes.push(o);o.style.top=(this.height*(this.length-1))+'px';
		}
		if(this.bPause==true) return;
		/*INCREMENT*/
		this.index++;
		/*순환형태가 아닌 up<->down반복일때*/
		if(this.index==this.length&&this.direction=='updn'&&this.dd){
			/*swap*/
			a[0]=this.Nodes[this.length-1];for(var i=1;i<this.length;i++){a[i]=this.Nodes[i-1];}this.Nodes=a;
			/*위치 재 지정*/
			for(var i=0;i<this.length;i++) this.Nodes[i].style.top=(this.height* i) + 'px';
			this.dd=false;
		}else if(this.index==this.length-1&&this.direction=='updn'&&!this.dd){
			/*swap*/
			for(var i=1;i<this.length;i++){a[i-1]=this.Nodes[i];}a[this.length-1]=this.Nodes[0];this.Nodes=a;
			/*위치 재 지정*/
			for(var i=0;i<this.length;i++) this.Nodes[i].style.top=(   this.height* ((this.length-1-i)*-1)  ) + 'px';
			/*방향상태값변경 후 중단*/
			this.dd=true;this.index=0;return false;
		}
		a=null; 
		/*이동대상 객체 선정 및 해당 객체의 이동단계값구하기*/
		for(var i=0;i<this.length;i++){
			pY=this.height* ( this.dd?(this.length-(2+i))*-1:i-1 );
			dY=pY-parseInt(this.Nodes[i].style.top);
			if(dY==0) continue;
			this.Queue[this.Queue.length]={style:this.Nodes[i].style,distY:dY,posY:parseInt(this.Nodes[i].style.top),mvY:pY,nBaud:dY!=0?0:this.nPeriod};
		}
		if(this.index>this.length) this.index=0;
	},
	/**
	 * 주어진 객체의 위치를 제어함수
	 */
	_aviate:function(){
		clearTimeout(this.resTime);this.resTime=null;
		var Toggle=null,Queue=[];
		var dY=0, nsec=0;
		for(var i=0,len=this.Queue.length;i<len;i++){
			Toggle=this.Queue[i];
			/*해당객체의 이동 카운트를 넘지 않은 경우 위치이동제어*/
			if(Toggle.nBaud < this.nPeriod){
				dY = Math.round(Math.sin(Toggle.nBaud / this.nPeriod*Math.PI/2)*Toggle.distY);
				Toggle.style.top=(Toggle.posY+dY)+'px';
				Toggle.nBaud++;
			}
			/*해당객체의 이동 카운트를 넘는경우 놓여질 위치에 객체 위치를 선정하고 중단*/
			if(Toggle.nBaud >= this.nPeriod ){
				Toggle.style.top=(Toggle.mvY)+'px';
			}else{
				Queue[Queue.length]=Toggle;
			}
		};
		/*객체이동이 끝난 경우 일시정지 후 중단*/
		if(Queue.length==0){
			/*일시 정지*/
			if(this.bPause==true){	return false;}
			this._stack();
			nsec=this.nDelay;
		}else{
			this.Queue=Queue;
		}
		this.resTime=setTimeout(this._aviate.bind(this),nsec);
	}
	
}